# I used two integers, length, and wordLength, to help me keep track of the assumed depth of my current node and the length of the current prefix. Then I have a DLBNode, currEndofSB, to keep track of the node that contains the last letter of the word that is added to the Trie. 
# When adding a word to the Trie. I will check if the word is valid or not. If it’s not valid, throw an exception. Otherwise, keep adding. It will check whether a root exists or not. If not, initialize the root with the first letter of the word. It checks whether the Trie contains the word or not anyway. If the Trie contains the word, we cannot add the word to the Trie. Then, we iterate through the Trie to add the word. If the current node has a sibling and the data of the node doesn’t match with the character in the word, then we go to check its sibling. If no more siblings exist and the data still does not match, we add a new node with the char as the sibling of the previous node. Then, we went to the child. And do the same thing to check the sibling list. But when adding a child to our current node, we need to set the data of the child one character after the current character to avoid duplicates. 
# I have 2 cases for advance, whether the prefix is a single letter or not. If it’s a single letter, then it means our pointer should go from the root. Otherwise, we need to go from the node that goes before. For a single-letter case, we will straight up checking the sibling list. But for the other case, we need to go to the current node’s child and check the child’s sibling list. 
# For retreat, if no prefix exists, throw an exception. I also have 2 cases when retreating. Because I think retreating the last character in the word will be the special case. If the depth and word length do not match or the data doesn’t match with the character, we will just delete the last character in the prefix. If retreating the last character, then it’s just reset. Reset will set all the references either to root or null. Then, set the depth we went and the word length back to 0. Then, initialize the current prefix to an empty StringBuilder. isWord method will determine if the current prefix is a prefix of the dictionary and whether it’s a word or not. getNumberOfPredictions returns 0 if the prefix does not exist in the dictionary, and a number if exists. retrievePrediction returns a String. For my implementation, if the prefix is already a word, just return that. Otherwise, we go down appending while finding a node whose isWord flagged true.
# Run-time Analysis:
# add (String word): The worst case would be adding n Zs to the Trie while the n-1 level of the Trie has no Z sibling attached to the Y node. So, the runtime should be O alphabet size*word. length).
# advance (char c): the worst case is we trying to find the very last node in the sibling list, which the runtime would be O (alphabet size).
# retreat (): The worst case is the data matches, but we are at the very last node in the sibling list, and we need to traverse to the first node to find the parent. Therefore, the runtime will be O (alphabet size).
# reset (): Reset will just simply set the data to 0 or null, and the reference to the beginning or null. Therefore, the runtime will always be O (1).
# isWord (): We can just check whether the current Node’s isWord flag and if the depth matches the word length or not. So, the runtime will always be O (1).
# add (): This add will call add (String word), therefore the worst-case runtime will be the same as add (String word), which is O(alphabet size * word. length).
# getNumberOfPredictions (): We can just check the size of the current Node and if the depth matches the word length or not. So, the runtime will always be O (1) because there’s no loop or traversal.
# retrievePrediction (): The method will keep going down through the Trie while finding a node flagged true for isWord. Therefore the runtime will be O (predictWord. length).

